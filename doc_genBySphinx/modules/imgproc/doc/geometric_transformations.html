<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Geometric Image Transformations &mdash; OpenCV 3.0.0-beta documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '3.0.0-beta',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../../../_static/insertIframe.js"></script>
    <link rel="top" title="OpenCV 3.0.0-beta documentation" href="../../../index.html" />
    <link rel="up" title="imgproc. Image Processing" href="imgproc.html" />
    <link rel="next" title="Miscellaneous Image Transformations" href="miscellaneous_transformations.html" />
    <link rel="prev" title="Image Filtering" href="filtering.html" />
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="miscellaneous_transformations.html" title="Miscellaneous Image Transformations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="filtering.html" title="Image Filtering"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 3.0.0-beta documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="imgproc.html" accesskey="U">imgproc. Image Processing</a> &raquo;</li> 
      </ul>
    </div>  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/opencv-logo2.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Geometric Image Transformations</a><ul>
<li><a class="reference internal" href="#convertmaps">convertMaps</a></li>
<li><a class="reference internal" href="#getaffinetransform">getAffineTransform</a></li>
<li><a class="reference internal" href="#getperspectivetransform">getPerspectiveTransform</a></li>
<li><a class="reference internal" href="#getrectsubpix">getRectSubPix</a></li>
<li><a class="reference internal" href="#getrotationmatrix2d">getRotationMatrix2D</a></li>
<li><a class="reference internal" href="#invertaffinetransform">invertAffineTransform</a></li>
<li><a class="reference internal" href="#linearpolar">LinearPolar</a></li>
<li><a class="reference internal" href="#logpolar">LogPolar</a></li>
<li><a class="reference internal" href="#remap">remap</a></li>
<li><a class="reference internal" href="#resize">resize</a></li>
<li><a class="reference internal" href="#warpaffine">warpAffine</a></li>
<li><a class="reference internal" href="#warpperspective">warpPerspective</a></li>
<li><a class="reference internal" href="#initundistortrectifymap">initUndistortRectifyMap</a></li>
<li><a class="reference internal" href="#getdefaultnewcameramatrix">getDefaultNewCameraMatrix</a></li>
<li><a class="reference internal" href="#undistort">undistort</a></li>
<li><a class="reference internal" href="#undistortpoints">undistortPoints</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="filtering.html"
                        title="previous chapter">Image Filtering</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="miscellaneous_transformations.html"
                        title="next chapter">Miscellaneous Image Transformations</a></p>
        </div>
      </div>
  <body>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="geometric-image-transformations">
<h1>Geometric Image Transformations<a class="headerlink" href="#geometric-image-transformations" title="Permalink to this headline">¶</a></h1>
<p>The functions in this section perform various geometrical transformations of 2D images. They do not change the image content but deform the pixel grid and map this deformed grid to the destination image. In fact, to avoid sampling artifacts, the mapping is done in the reverse order, from destination to the source. That is, for each pixel <span class="math">(x, y)</span> of the destination image, the functions compute    coordinates of the corresponding &#8220;donor&#8221; pixel in the source image and copy the pixel value:</p>
<div class="math">
<p><span class="math">\texttt{dst} (x,y)= \texttt{src} (f_x(x,y), f_y(x,y))</span></p>
</div><p>In case when you specify the forward mapping
<span class="math">\left&lt;g_x, g_y\right&gt;: \texttt{src} \rightarrow \texttt{dst}</span> , the OpenCV functions first compute the corresponding inverse mapping
<span class="math">\left&lt;f_x, f_y\right&gt;: \texttt{dst} \rightarrow \texttt{src}</span> and then use the above formula.</p>
<p>The actual implementations of the geometrical transformations, from the most generic
<a class="reference internal" href="#void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)" title="void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">remap()</span></tt></a> and to the simplest and the fastest
<a class="reference internal" href="#void resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation)" title="void resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">resize()</span></tt></a> , need to solve two main problems with the above formula:</p>
<ul class="simple">
<li>Extrapolation of non-existing pixels. Similarly to the filtering functions described in the previous section, for some
<span class="math">(x,y)</span>  ,   either one of
<span class="math">f_x(x,y)</span>   ,  or
<span class="math">f_y(x,y)</span>     , or both of them may fall outside of the image. In this case, an extrapolation method needs to be used. OpenCV provides the same selection of extrapolation methods as in the filtering functions. In addition, it provides the method <tt class="docutils literal"><span class="pre">BORDER_TRANSPARENT</span></tt>   . This means that the corresponding pixels in the destination image will not be modified at all.</li>
<li>Interpolation of pixel values. Usually
<span class="math">f_x(x,y)</span>     and
<span class="math">f_y(x,y)</span>     are floating-point numbers. This means that
<span class="math">\left&lt;f_x, f_y\right&gt;</span>     can be either an affine or perspective transformation, or radial lens distortion correction, and so on. So, a pixel value at fractional coordinates needs to be retrieved. In the simplest case, the coordinates can be just rounded to the nearest integer coordinates and the corresponding pixel can be used. This is called a nearest-neighbor interpolation. However, a better result can be achieved by using more sophisticated <a class="reference external" href="http://en.wikipedia.org/wiki/Multivariate_interpolation">interpolation methods</a>
, where a polynomial function is fit into some neighborhood of the computed pixel
<span class="math">(f_x(x,y), f_y(x,y))</span>   ,  and then the value of the polynomial at
<span class="math">(f_x(x,y), f_y(x,y))</span>     is taken as the interpolated pixel value. In OpenCV, you can choose between several interpolation methods. See
<a class="reference internal" href="#void resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation)" title="void resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">resize()</span></tt></a>   for details.</li>
</ul>
<div class="section" id="convertmaps">
<h2>convertMaps<a class="headerlink" href="#convertmaps" title="Permalink to this headline">¶</a></h2>
<p>Converts image transformation maps from one representation to another.</p>
<dl class="function">
<dt id="void convertMaps(InputArray map1, InputArray map2, OutputArray dstmap1, OutputArray dstmap2, int dstmap1type, bool nninterpolation)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">convertMaps</tt><big>(</big>InputArray <strong>map1</strong>, InputArray <strong>map2</strong>, OutputArray <strong>dstmap1</strong>, OutputArray <strong>dstmap2</strong>, int <strong>dstmap1type</strong>, bool <strong>nninterpolation</strong>=false <big>)</big><a class="headerlink" href="#void convertMaps(InputArray map1, InputArray map2, OutputArray dstmap1, OutputArray dstmap2, int dstmap1type, bool nninterpolation)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.convertMaps">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">convertMaps</tt><big>(</big>map1, map2, dstmap1type<span class="optional">[</span>, dstmap1<span class="optional">[</span>, dstmap2<span class="optional">[</span>, nninterpolation<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dstmap1, dstmap2<a class="headerlink" href="#cv2.convertMaps" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map1</strong> &#8211; The first input map of type  <tt class="docutils literal"><span class="pre">CV_16SC2</span></tt>  ,  <tt class="docutils literal"><span class="pre">CV_32FC1</span></tt> , or  <tt class="docutils literal"><span class="pre">CV_32FC2</span></tt> .</li>
<li><strong>map2</strong> &#8211; The second input map of type  <tt class="docutils literal"><span class="pre">CV_16UC1</span></tt>  , <tt class="docutils literal"><span class="pre">CV_32FC1</span></tt>  , or none (empty matrix), respectively.</li>
<li><strong>dstmap1</strong> &#8211; The first output map that has the type  <tt class="docutils literal"><span class="pre">dstmap1type</span></tt>  and the same size as  <tt class="docutils literal"><span class="pre">src</span></tt> .</li>
<li><strong>dstmap2</strong> &#8211; The second output map.</li>
<li><strong>dstmap1type</strong> &#8211; Type of the first output map that should be  <tt class="docutils literal"><span class="pre">CV_16SC2</span></tt> , <tt class="docutils literal"><span class="pre">CV_32FC1</span></tt> , or  <tt class="docutils literal"><span class="pre">CV_32FC2</span></tt> .</li>
<li><strong>nninterpolation</strong> &#8211; Flag indicating whether the fixed-point maps are used for the nearest-neighbor or for a more complex interpolation.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function converts a pair of maps for
<a class="reference internal" href="#void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)" title="void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">remap()</span></tt></a> from one representation to another. The following options ( <tt class="docutils literal"><span class="pre">(map1.type(),</span> <span class="pre">map2.type())</span></tt> <span class="math">\rightarrow</span> <tt class="docutils literal"><span class="pre">(dstmap1.type(),</span> <span class="pre">dstmap2.type())</span></tt> ) are supported:</p>
<ul class="simple">
<li><span class="math">\texttt{(CV\_32FC1, CV\_32FC1)} \rightarrow \texttt{(CV\_16SC2, CV\_16UC1)}</span>     . This is the most frequently used conversion operation, in which the original floating-point maps (see
<a class="reference internal" href="#void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)" title="void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">remap()</span></tt></a>     ) are converted to a more compact and much faster fixed-point representation. The first output array contains the rounded coordinates and the second array (created only when <tt class="docutils literal"><span class="pre">nninterpolation=false</span></tt>     ) contains indices in the interpolation tables.</li>
<li><span class="math">\texttt{(CV\_32FC2)} \rightarrow \texttt{(CV\_16SC2, CV\_16UC1)}</span>     . The same as above but the original maps are stored in one 2-channel matrix.</li>
<li>Reverse conversion. Obviously, the reconstructed floating-point maps will not be exactly the same as the originals.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)" title="void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">remap()</span></tt></a>,
<a class="reference internal" href="#void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix)" title="void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">undistort()</span></tt></a>,
<a class="reference internal" href="#void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)" title="void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">initUndistortRectifyMap()</span></tt></a></p>
</div>
</div>
<div class="section" id="getaffinetransform">
<h2>getAffineTransform<a class="headerlink" href="#getaffinetransform" title="Permalink to this headline">¶</a></h2>
<p>Calculates an affine transform from three pairs of the corresponding points.</p>
<dl class="function">
<dt id="Mat getAffineTransform(InputArray src, InputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descname">getAffineTransform</tt><big>(</big>InputArray <strong>src</strong>, InputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#Mat getAffineTransform(InputArray src, InputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat getAffineTransform(const Point2f src[], const Point2f dst[])">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descname">getAffineTransform</tt><big>(</big>const Point2f <strong>src</strong>[], const Point2f <strong>dst</strong>[]<big>)</big><a class="headerlink" href="#Mat getAffineTransform(const Point2f src[], const Point2f dst[])" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.getAffineTransform">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">getAffineTransform</tt><big>(</big>src, dst<big>)</big> &rarr; retval<a class="headerlink" href="#cv2.getAffineTransform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="CvMat* cvGetAffineTransform(const CvPoint2D32f * src, const CvPoint2D32f * dst, CvMat * map_matrix)">
<strong>C:</strong><tt class="descname"> </tt>CvMat* <tt class="descname">cvGetAffineTransform</tt><big>(</big>const CvPoint2D32f* <strong>src</strong>, const CvPoint2D32f* <strong>dst</strong>, CvMat* <strong>map_matrix</strong><big>)</big><a class="headerlink" href="#CvMat* cvGetAffineTransform(const CvPoint2D32f * src, const CvPoint2D32f * dst, CvMat * map_matrix)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Coordinates of triangle vertices in the source image.</li>
<li><strong>dst</strong> &#8211; Coordinates of the corresponding triangle vertices in the destination image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function calculates the <span class="math">2 \times 3</span> matrix of an affine transform so that:</p>
<div class="math">
<p><span class="math">\begin{bmatrix} x'_i \\ y'_i \end{bmatrix} = \texttt{map\_matrix} \cdot \begin{bmatrix} x_i \\ y_i \\ 1 \end{bmatrix}</span></p>
</div><p>where</p>
<div class="math">
<p><span class="math">dst(i)=(x'_i,y'_i),
src(i)=(x_i, y_i),
i=0,1,2</span></p>
</div><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)" title="void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">warpAffine()</span></tt></a>,
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#void transform(InputArray src, OutputArray dst, InputArray m)" title="void transform(InputArray src, OutputArray dst, InputArray m)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">transform()</span></tt></a></p>
</div>
</div>
<div class="section" id="getperspectivetransform">
<h2>getPerspectiveTransform<a class="headerlink" href="#getperspectivetransform" title="Permalink to this headline">¶</a></h2>
<p>Calculates a perspective transform from four pairs of the corresponding points.</p>
<dl class="function">
<dt id="Mat getPerspectiveTransform(InputArray src, InputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descname">getPerspectiveTransform</tt><big>(</big>InputArray <strong>src</strong>, InputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#Mat getPerspectiveTransform(InputArray src, InputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat getPerspectiveTransform(const Point2f src[], const Point2f dst[])">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descname">getPerspectiveTransform</tt><big>(</big>const Point2f <strong>src</strong>[], const Point2f <strong>dst</strong>[]<big>)</big><a class="headerlink" href="#Mat getPerspectiveTransform(const Point2f src[], const Point2f dst[])" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.getPerspectiveTransform">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">getPerspectiveTransform</tt><big>(</big>src, dst<big>)</big> &rarr; retval<a class="headerlink" href="#cv2.getPerspectiveTransform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="CvMat* cvGetPerspectiveTransform(const CvPoint2D32f* src, const CvPoint2D32f* dst, CvMat* map_matrix)">
<strong>C:</strong><tt class="descname"> </tt>CvMat* <tt class="descname">cvGetPerspectiveTransform</tt><big>(</big>const CvPoint2D32f* <strong>src</strong>, const CvPoint2D32f* <strong>dst</strong>, CvMat* <strong>map_matrix</strong><big>)</big><a class="headerlink" href="#CvMat* cvGetPerspectiveTransform(const CvPoint2D32f* src, const CvPoint2D32f* dst, CvMat* map_matrix)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Coordinates of quadrangle vertices in the source image.</li>
<li><strong>dst</strong> &#8211; Coordinates of the corresponding quadrangle vertices in the destination image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function calculates the <span class="math">3 \times 3</span> matrix of a perspective transform so that:</p>
<div class="math">
<p><span class="math">\begin{bmatrix} t_i x'_i \\ t_i y'_i \\ t_i \end{bmatrix} = \texttt{map\_matrix} \cdot \begin{bmatrix} x_i \\ y_i \\ 1 \end{bmatrix}</span></p>
</div><p>where</p>
<div class="math">
<p><span class="math">dst(i)=(x'_i,y'_i),
src(i)=(x_i, y_i),
i=0,1,2,3</span></p>
</div><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method, double ransacReprojThreshold, OutputArray mask, const int maxIters , const double confidence)" title="Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method, double ransacReprojThreshold, OutputArray mask, const int maxIters , const double confidence)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">findHomography()</span></tt></a>,
<a class="reference internal" href="#void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)" title="void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">warpPerspective()</span></tt></a>,
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#void perspectiveTransform(InputArray src, OutputArray dst, InputArray m)" title="void perspectiveTransform(InputArray src, OutputArray dst, InputArray m)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">perspectiveTransform()</span></tt></a></p>
</div>
</div>
<div class="section" id="getrectsubpix">
<h2>getRectSubPix<a class="headerlink" href="#getrectsubpix" title="Permalink to this headline">¶</a></h2>
<p>Retrieves a pixel rectangle from an image with sub-pixel accuracy.</p>
<dl class="function">
<dt id="void getRectSubPix(InputArray image, Size patchSize, Point2f center, OutputArray patch, int patchType)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">getRectSubPix</tt><big>(</big>InputArray <strong>image</strong>, Size <strong>patchSize</strong>, Point2f <strong>center</strong>, OutputArray <strong>patch</strong>, int <strong>patchType</strong>=-1 <big>)</big><a class="headerlink" href="#void getRectSubPix(InputArray image, Size patchSize, Point2f center, OutputArray patch, int patchType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.getRectSubPix">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">getRectSubPix</tt><big>(</big>image, patchSize, center<span class="optional">[</span>, patch<span class="optional">[</span>, patchType<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; patch<a class="headerlink" href="#cv2.getRectSubPix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvGetRectSubPix(const CvArr* src, CvArr* dst, CvPoint2D32f center)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvGetRectSubPix</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, CvPoint2D32f <strong>center</strong><big>)</big><a class="headerlink" href="#void cvGetRectSubPix(const CvArr* src, CvArr* dst, CvPoint2D32f center)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source image.</li>
<li><strong>patchSize</strong> &#8211; Size of the extracted patch.</li>
<li><strong>center</strong> &#8211; Floating point coordinates of the center of the extracted rectangle within the source image. The center must be inside the image.</li>
<li><strong>dst</strong> &#8211; Extracted patch that has the size  <tt class="docutils literal"><span class="pre">patchSize</span></tt>  and the same number of channels as  <tt class="docutils literal"><span class="pre">src</span></tt> .</li>
<li><strong>patchType</strong> &#8211; Depth of the extracted pixels. By default, they have the same depth as  <tt class="docutils literal"><span class="pre">src</span></tt> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">getRectSubPix</span></tt> extracts pixels from <tt class="docutils literal"><span class="pre">src</span></tt> :</p>
<div class="math">
<p><span class="math">dst(x, y) = src(x +  \texttt{center.x} - ( \texttt{dst.cols} -1)*0.5, y +  \texttt{center.y} - ( \texttt{dst.rows} -1)*0.5)</span></p>
</div><p>where the values of the pixels at non-integer coordinates are retrieved
using bilinear interpolation. Every channel of multi-channel
images is processed independently. While the center of the rectangle
must be inside the image, parts of the rectangle may be
outside. In this case, the replication border mode (see
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a> ) is used to extrapolate
the pixel values outside of the image.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)" title="void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">warpAffine()</span></tt></a>,
<a class="reference internal" href="#void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)" title="void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">warpPerspective()</span></tt></a></p>
</div>
</div>
<div class="section" id="getrotationmatrix2d">
<h2>getRotationMatrix2D<a class="headerlink" href="#getrotationmatrix2d" title="Permalink to this headline">¶</a></h2>
<p>Calculates an affine matrix of 2D rotation.</p>
<dl class="function">
<dt id="Mat getRotationMatrix2D(Point2f center, double angle, double scale)">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descname">getRotationMatrix2D</tt><big>(</big>Point2f <strong>center</strong>, double <strong>angle</strong>, double <strong>scale</strong><big>)</big><a class="headerlink" href="#Mat getRotationMatrix2D(Point2f center, double angle, double scale)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.getRotationMatrix2D">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">getRotationMatrix2D</tt><big>(</big>center, angle, scale<big>)</big> &rarr; retval<a class="headerlink" href="#cv2.getRotationMatrix2D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="CvMat* cv2DRotationMatrix(CvPoint2D32f center, double angle, double scale, CvMat* map_matrix)">
<strong>C:</strong><tt class="descname"> </tt>CvMat* <tt class="descname">cv2DRotationMatrix</tt><big>(</big>CvPoint2D32f <strong>center</strong>, double <strong>angle</strong>, double <strong>scale</strong>, CvMat* <strong>map_matrix</strong><big>)</big><a class="headerlink" href="#CvMat* cv2DRotationMatrix(CvPoint2D32f center, double angle, double scale, CvMat* map_matrix)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>center</strong> &#8211; Center of the rotation in the source image.</li>
<li><strong>angle</strong> &#8211; Rotation angle in degrees. Positive values mean counter-clockwise rotation (the coordinate origin is assumed to be the top-left corner).</li>
<li><strong>scale</strong> &#8211; Isotropic scale factor.</li>
<li><strong>map_matrix</strong> &#8211; The output affine transformation, 2x3 floating-point matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function calculates the following matrix:</p>
<div class="math">
<p><span class="math">\begin{bmatrix} \alpha &amp;  \beta &amp; (1- \alpha )  \cdot \texttt{center.x} -  \beta \cdot \texttt{center.y} \\ - \beta &amp;  \alpha &amp;  \beta \cdot \texttt{center.x} + (1- \alpha )  \cdot \texttt{center.y} \end{bmatrix}</span></p>
</div><p>where</p>
<div class="math">
<p><span class="math">\begin{array}{l} \alpha =  \texttt{scale} \cdot \cos \texttt{angle} , \\ \beta =  \texttt{scale} \cdot \sin \texttt{angle} \end{array}</span></p>
</div><p>The transformation maps the rotation center to itself. If this is not the target, adjust the shift.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#Mat getAffineTransform(InputArray src, InputArray dst)" title="Mat getAffineTransform(InputArray src, InputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getAffineTransform()</span></tt></a>,
<a class="reference internal" href="#void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)" title="void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">warpAffine()</span></tt></a>,
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#void transform(InputArray src, OutputArray dst, InputArray m)" title="void transform(InputArray src, OutputArray dst, InputArray m)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">transform()</span></tt></a></p>
</div>
</div>
<div class="section" id="invertaffinetransform">
<h2>invertAffineTransform<a class="headerlink" href="#invertaffinetransform" title="Permalink to this headline">¶</a></h2>
<p>Inverts an affine transformation.</p>
<dl class="function">
<dt id="void invertAffineTransform(InputArray M, OutputArray iM)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">invertAffineTransform</tt><big>(</big>InputArray <strong>M</strong>, OutputArray <strong>iM</strong><big>)</big><a class="headerlink" href="#void invertAffineTransform(InputArray M, OutputArray iM)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.invertAffineTransform">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">invertAffineTransform</tt><big>(</big>M<span class="optional">[</span>, iM<span class="optional">]</span><big>)</big> &rarr; iM<a class="headerlink" href="#cv2.invertAffineTransform" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>M</strong> &#8211; Original affine transformation.</li>
<li><strong>iM</strong> &#8211; Output reverse affine transformation.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes an inverse affine transformation represented by
<span class="math">2 \times 3</span> matrix <tt class="docutils literal"><span class="pre">M</span></tt> :</p>
<div class="math">
<p><span class="math">\begin{bmatrix} a_{11} &amp; a_{12} &amp; b_1  \\ a_{21} &amp; a_{22} &amp; b_2 \end{bmatrix}</span></p>
</div><p>The result is also a
<span class="math">2 \times 3</span> matrix of the same type as <tt class="docutils literal"><span class="pre">M</span></tt> .</p>
</div>
<div class="section" id="linearpolar">
<h2>LinearPolar<a class="headerlink" href="#linearpolar" title="Permalink to this headline">¶</a></h2>
<p>Remaps an image to polar space.</p>
<dl class="cfunction">
<dt id="void cvLinearPolar(const CvArr* src, CvArr* dst, CvPoint2D32f center, double maxRadius, int flags)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvLinearPolar</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, CvPoint2D32f <strong>center</strong>, double <strong>maxRadius</strong>, int <strong>flags</strong>=CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS <big>)</big><a class="headerlink" href="#void cvLinearPolar(const CvArr* src, CvArr* dst, CvPoint2D32f center, double maxRadius, int flags)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source image</li>
<li><strong>dst</strong> &#8211; Destination image</li>
<li><strong>center</strong> &#8211; The transformation center;</li>
<li><strong>maxRadius</strong> &#8211; Inverse magnitude scale parameter. See below</li>
<li><strong>flags</strong> &#8211; <p>A combination of interpolation methods and the following optional flags:</p>
<ul>
<li><strong>CV_WARP_FILL_OUTLIERS</strong> fills all of the destination image pixels. If some of them correspond to outliers in the source image, they are set to zero</li>
<li><strong>CV_WARP_INVERSE_MAP</strong> See below</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">cvLinearPolar</span></tt> transforms the source image using the following transformation:</p>
<blockquote>
<div><ul>
<li><p class="first">Forward transformation (<tt class="docutils literal"><span class="pre">CV_WARP_INVERSE_MAP</span></tt> is not set):</p>
<blockquote>
<div><div class="math">
<p><span class="math">dst( \phi , \rho ) = src(x,y)</span></p>
</div></div></blockquote>
</li>
<li><p class="first">Inverse transformation (<tt class="docutils literal"><span class="pre">CV_WARP_INVERSE_MAP</span></tt> is set):</p>
<blockquote>
<div><div class="math">
<p><span class="math">dst(x,y) = src( \phi , \rho )</span></p>
</div></div></blockquote>
</li>
</ul>
</div></blockquote>
<p>where</p>
<blockquote>
<div><div class="math">
<p><span class="math">\rho = (src.width/maxRadius)  \cdot \sqrt{x^2 + y^2} , \phi =atan(y/x)</span></p>
</div></div></blockquote>
<p>The function can not operate in-place.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the LinearPolar operation can be found at opencv_source_code/samples/c/polar_transforms.c</li>
</ul>
</div>
</div>
<div class="section" id="logpolar">
<h2>LogPolar<a class="headerlink" href="#logpolar" title="Permalink to this headline">¶</a></h2>
<p>Remaps an image to log-polar space.</p>
<dl class="cfunction">
<dt id="void cvLogPolar(const CvArr* src, CvArr* dst, CvPoint2D32f center, double M, int flags)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvLogPolar</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, CvPoint2D32f <strong>center</strong>, double <strong>M</strong>, int <strong>flags</strong>=CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS <big>)</big><a class="headerlink" href="#void cvLogPolar(const CvArr* src, CvArr* dst, CvPoint2D32f center, double M, int flags)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source image</li>
<li><strong>dst</strong> &#8211; Destination image</li>
<li><strong>center</strong> &#8211; The transformation center; where the output precision is maximal</li>
<li><strong>M</strong> &#8211; Magnitude scale parameter. See below</li>
<li><strong>flags</strong> &#8211; <p>A combination of interpolation methods and the following optional flags:</p>
<ul>
<li><strong>CV_WARP_FILL_OUTLIERS</strong> fills all of the destination image pixels. If some of them correspond to outliers in the source image, they are set to zero</li>
<li><strong>CV_WARP_INVERSE_MAP</strong> See below</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">cvLogPolar</span></tt> transforms the source image using the following transformation:</p>
<blockquote>
<div><ul>
<li><p class="first">Forward transformation (<tt class="docutils literal"><span class="pre">CV_WARP_INVERSE_MAP</span></tt> is not set):</p>
<blockquote>
<div><div class="math">
<p><span class="math">dst( \phi , \rho ) = src(x,y)</span></p>
</div></div></blockquote>
</li>
<li><p class="first">Inverse transformation (<tt class="docutils literal"><span class="pre">CV_WARP_INVERSE_MAP</span></tt> is set):</p>
<blockquote>
<div><div class="math">
<p><span class="math">dst(x,y) = src( \phi , \rho )</span></p>
</div></div></blockquote>
</li>
</ul>
</div></blockquote>
<p>where</p>
<blockquote>
<div><div class="math">
<p><span class="math">\rho = M  \cdot \log{\sqrt{x^2 + y^2}} , \phi =atan(y/x)</span></p>
</div></div></blockquote>
<p>The function emulates the human &#8220;foveal&#8221; vision and can be used for fast scale and rotation-invariant template matching, for object tracking and so forth. The function can not operate in-place.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the geometric logpolar operation in 4 applications can be found at opencv_source_code/samples/cpp/logpolar_bsm.cpp</li>
</ul>
</div>
</div>
<div class="section" id="remap">
<h2>remap<a class="headerlink" href="#remap" title="Permalink to this headline">¶</a></h2>
<p>Applies a generic geometrical transformation to an image.</p>
<dl class="function">
<dt id="void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">remap</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, InputArray <strong>map1</strong>, InputArray <strong>map2</strong>, int <strong>interpolation</strong>, int <strong>borderMode</strong>=BORDER_CONSTANT, const Scalar&amp; <strong>borderValue</strong>=Scalar()<big>)</big><a class="headerlink" href="#void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar& borderValue)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.remap">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">remap</tt><big>(</big>src, map1, map2, interpolation<span class="optional">[</span>, dst<span class="optional">[</span>, borderMode<span class="optional">[</span>, borderValue<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.remap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvRemap(const CvArr* src, CvArr* dst, const CvArr* mapx, const CvArr* mapy, int flags, CvScalar fillval)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvRemap</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, const CvArr* <strong>mapx</strong>, const CvArr* <strong>mapy</strong>, int <strong>flags</strong>=CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS, CvScalar <strong>fillval</strong>=cvScalarAll(0) <big>)</big><a class="headerlink" href="#void cvRemap(const CvArr* src, CvArr* dst, const CvArr* mapx, const CvArr* mapy, int flags, CvScalar fillval)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source image.</li>
<li><strong>dst</strong> &#8211; Destination image. It has the same size as  <tt class="docutils literal"><span class="pre">map1</span></tt>  and the same type as  <tt class="docutils literal"><span class="pre">src</span></tt> .</li>
<li><strong>map1</strong> &#8211; The first map of either  <tt class="docutils literal"><span class="pre">(x,y)</span></tt>  points or just  <tt class="docutils literal"><span class="pre">x</span></tt>  values having the type  <tt class="docutils literal"><span class="pre">CV_16SC2</span></tt> , <tt class="docutils literal"><span class="pre">CV_32FC1</span></tt> , or  <tt class="docutils literal"><span class="pre">CV_32FC2</span></tt> . See  <a class="reference internal" href="#void convertMaps(InputArray map1, InputArray map2, OutputArray dstmap1, OutputArray dstmap2, int dstmap1type, bool nninterpolation)" title="void convertMaps(InputArray map1, InputArray map2, OutputArray dstmap1, OutputArray dstmap2, int dstmap1type, bool nninterpolation)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">convertMaps()</span></tt></a>  for details on converting a floating point representation to fixed-point for speed.</li>
<li><strong>map2</strong> &#8211; The second map of  <tt class="docutils literal"><span class="pre">y</span></tt>  values having the type  <tt class="docutils literal"><span class="pre">CV_16UC1</span></tt> , <tt class="docutils literal"><span class="pre">CV_32FC1</span></tt> , or none (empty map if <tt class="docutils literal"><span class="pre">map1</span></tt> is  <tt class="docutils literal"><span class="pre">(x,y)</span></tt>  points), respectively.</li>
<li><strong>interpolation</strong> &#8211; Interpolation method (see  <a class="reference internal" href="#void resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation)" title="void resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">resize()</span></tt></a> ). The method  <tt class="docutils literal"><span class="pre">INTER_AREA</span></tt>  is not supported by this function.</li>
<li><strong>borderMode</strong> &#8211; Pixel extrapolation method (see  <a class="reference internal" href="../../core/doc/operations_on_arrays.html#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a> ). When   <tt class="docutils literal"><span class="pre">borderMode=BORDER_TRANSPARENT</span></tt> , it means that the pixels in the destination image that corresponds to the &#8220;outliers&#8221; in the source image are not modified by the function.</li>
<li><strong>borderValue</strong> &#8211; Value used in case of a constant border. By default, it is 0.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">remap</span></tt> transforms the source image using the specified map:</p>
<div class="math">
<p><span class="math">\texttt{dst} (x,y) =  \texttt{src} (map_x(x,y),map_y(x,y))</span></p>
</div><p>where values of pixels with non-integer coordinates are computed using one of available interpolation methods.
<span class="math">map_x</span> and
<span class="math">map_y</span> can be encoded as separate floating-point maps in
<span class="math">map_1</span> and
<span class="math">map_2</span> respectively, or interleaved floating-point maps of
<span class="math">(x,y)</span> in
<span class="math">map_1</span> , or
fixed-point maps created by using
<a class="reference internal" href="#void convertMaps(InputArray map1, InputArray map2, OutputArray dstmap1, OutputArray dstmap2, int dstmap1type, bool nninterpolation)" title="void convertMaps(InputArray map1, InputArray map2, OutputArray dstmap1, OutputArray dstmap2, int dstmap1type, bool nninterpolation)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">convertMaps()</span></tt></a> . The reason you might want to convert from floating to fixed-point
representations of a map is that they can yield much faster (~2x) remapping operations. In the converted case,
<span class="math">map_1</span> contains pairs <tt class="docutils literal"><span class="pre">(cvFloor(x),</span> <span class="pre">cvFloor(y))</span></tt> and
<span class="math">map_2</span> contains indices in a table of interpolation coefficients.</p>
<p>This function cannot operate in-place.</p>
</div>
<div class="section" id="resize">
<h2>resize<a class="headerlink" href="#resize" title="Permalink to this headline">¶</a></h2>
<p>Resizes an image.</p>
<dl class="function">
<dt id="void resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">resize</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, Size <strong>dsize</strong>, double <strong>fx</strong>=0, double <strong>fy</strong>=0, int <strong>interpolation</strong>=INTER_LINEAR <big>)</big><a class="headerlink" href="#void resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.resize">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">resize</tt><big>(</big>src, dsize<span class="optional">[</span>, dst<span class="optional">[</span>, fx<span class="optional">[</span>, fy<span class="optional">[</span>, interpolation<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvResize(const CvArr* src, CvArr* dst, int interpolation)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvResize</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>interpolation</strong>=CV_INTER_LINEAR <big>)</big><a class="headerlink" href="#void cvResize(const CvArr* src, CvArr* dst, int interpolation)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image.</li>
<li><strong>dst</strong> &#8211; output image; it has the size <tt class="docutils literal"><span class="pre">dsize</span></tt> (when it is non-zero) or the size computed from <tt class="docutils literal"><span class="pre">src.size()</span></tt>, <tt class="docutils literal"><span class="pre">fx</span></tt>, and <tt class="docutils literal"><span class="pre">fy</span></tt>; the type of <tt class="docutils literal"><span class="pre">dst</span></tt> is the same as of <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>dsize</strong> &#8211; <p>output image size; if it equals zero, it is computed as:</p>
<div class="math">
<p><span class="math">\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}</span></p>
</div><p>Either  <tt class="docutils literal"><span class="pre">dsize</span></tt>  or both  <tt class="docutils literal"><span class="pre">fx</span></tt>  and  <tt class="docutils literal"><span class="pre">fy</span></tt>  must be non-zero.</p>
</li>
<li><strong>fx</strong> &#8211; <p>scale factor along the horizontal axis; when it equals 0, it is computed as</p>
<div class="math">
<p><span class="math">\texttt{(double)dsize.width/src.cols}</span></p>
</div></li>
<li><strong>fy</strong> &#8211; <p>scale factor along the vertical axis; when it equals 0, it is computed as</p>
<div class="math">
<p><span class="math">\texttt{(double)dsize.height/src.rows}</span></p>
</div></li>
<li><strong>interpolation</strong> &#8211; <p>interpolation method:</p>
<ul>
<li><strong>INTER_NEAREST</strong> - a nearest-neighbor interpolation</li>
<li><strong>INTER_LINEAR</strong> - a bilinear interpolation (used by default)</li>
<li><strong>INTER_AREA</strong> - resampling using pixel area relation. It may be a preferred method for image decimation, as it gives moire&#8217;-free results. But when the image is zoomed, it is similar to the  <tt class="docutils literal"><span class="pre">INTER_NEAREST</span></tt>  method.</li>
<li><strong>INTER_CUBIC</strong>  - a bicubic interpolation over 4x4 pixel neighborhood</li>
<li><strong>INTER_LANCZOS4</strong> - a Lanczos interpolation over 8x8 pixel neighborhood</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">resize</span></tt> resizes the image <tt class="docutils literal"><span class="pre">src</span></tt> down to or up to the specified size.
Note that the initial <tt class="docutils literal"><span class="pre">dst</span></tt> type or size are not taken into account. Instead, the size and type are derived from the <tt class="docutils literal"><span class="pre">src</span></tt>,``dsize``,``fx`` , and <tt class="docutils literal"><span class="pre">fy</span></tt> . If you want to resize <tt class="docutils literal"><span class="pre">src</span></tt> so that it fits the pre-created <tt class="docutils literal"><span class="pre">dst</span></tt> , you may call the function as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// explicitly specify dsize=dst.size(); fx and fy will be computed from that.</span>
<span class="n">resize</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">dst</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">);</span>
</pre></div>
</div>
<p>If you want to decimate the image by factor of 2 in each direction, you can call the function this way:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// specify fx and fy and let the function compute the destination image size.</span>
<span class="n">resize</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">Size</span><span class="p">(),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">);</span>
</pre></div>
</div>
<p>To shrink an image, it will generally look best with CV_INTER_AREA interpolation, whereas to enlarge an image, it will generally look best with CV_INTER_CUBIC (slow) or CV_INTER_LINEAR (faster but still looks OK).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)" title="void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">warpAffine()</span></tt></a>,
<a class="reference internal" href="#void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)" title="void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">warpPerspective()</span></tt></a>,
<a class="reference internal" href="#void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)" title="void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">remap()</span></tt></a></p>
</div>
</div>
<div class="section" id="warpaffine">
<h2>warpAffine<a class="headerlink" href="#warpaffine" title="Permalink to this headline">¶</a></h2>
<p>Applies an affine transformation to an image.</p>
<dl class="function">
<dt id="void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">warpAffine</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, InputArray <strong>M</strong>, Size <strong>dsize</strong>, int <strong>flags</strong>=INTER_LINEAR, int <strong>borderMode</strong>=BORDER_CONSTANT, const Scalar&amp; <strong>borderValue</strong>=Scalar()<big>)</big><a class="headerlink" href="#void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar& borderValue)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.warpAffine">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">warpAffine</tt><big>(</big>src, M, dsize<span class="optional">[</span>, dst<span class="optional">[</span>, flags<span class="optional">[</span>, borderMode<span class="optional">[</span>, borderValue<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.warpAffine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvWarpAffine(const CvArr* src, CvArr* dst, const CvMat* map_matrix, int flags, CvScalar fillval)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvWarpAffine</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, const CvMat* <strong>map_matrix</strong>, int <strong>flags</strong>=CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS, CvScalar <strong>fillval</strong>=cvScalarAll(0) <big>)</big><a class="headerlink" href="#void cvWarpAffine(const CvArr* src, CvArr* dst, const CvMat* map_matrix, int flags, CvScalar fillval)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvGetQuadrangleSubPix(const CvArr* src, CvArr* dst, const CvMat* map_matrix)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvGetQuadrangleSubPix</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, const CvMat* <strong>map_matrix</strong><big>)</big><a class="headerlink" href="#void cvGetQuadrangleSubPix(const CvArr* src, CvArr* dst, const CvMat* map_matrix)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image.</li>
<li><strong>dst</strong> &#8211; output image that has the size  <tt class="docutils literal"><span class="pre">dsize</span></tt>  and the same type as  <tt class="docutils literal"><span class="pre">src</span></tt> .</li>
<li><strong>M</strong> &#8211; <span class="math">2\times 3</span> transformation matrix.</li>
<li><strong>dsize</strong> &#8211; size of the output image.</li>
<li><strong>flags</strong> &#8211; combination of interpolation methods (see  <a class="reference internal" href="#void resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation)" title="void resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">resize()</span></tt></a> ) and the optional flag <tt class="docutils literal"><span class="pre">WARP_INVERSE_MAP</span></tt> that means that <tt class="docutils literal"><span class="pre">M</span></tt> is the inverse transformation ( <span class="math">\texttt{dst}\rightarrow\texttt{src}</span> ).</li>
<li><strong>borderMode</strong> &#8211; pixel extrapolation method (see <a class="reference internal" href="../../core/doc/operations_on_arrays.html#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a>); when    <tt class="docutils literal"><span class="pre">borderMode=BORDER_TRANSPARENT</span></tt> , it means that the pixels in the destination image corresponding to the &#8220;outliers&#8221; in the source image are not modified by the function.</li>
<li><strong>borderValue</strong> &#8211; value used in case of a constant border; by default, it is 0.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">warpAffine</span></tt> transforms the source image using the specified matrix:</p>
<div class="math">
<p><span class="math">\texttt{dst} (x,y) =  \texttt{src} ( \texttt{M} _{11} x +  \texttt{M} _{12} y +  \texttt{M} _{13}, \texttt{M} _{21} x +  \texttt{M} _{22} y +  \texttt{M} _{23})</span></p>
</div><p>when the flag <tt class="docutils literal"><span class="pre">WARP_INVERSE_MAP</span></tt> is set. Otherwise, the transformation is first inverted with
<a class="reference internal" href="#void invertAffineTransform(InputArray M, OutputArray iM)" title="void invertAffineTransform(InputArray M, OutputArray iM)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">invertAffineTransform()</span></tt></a> and then put in the formula above instead of <tt class="docutils literal"><span class="pre">M</span></tt> .
The function cannot operate in-place.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)" title="void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">warpPerspective()</span></tt></a>,
<a class="reference internal" href="#void resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation)" title="void resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">resize()</span></tt></a>,
<a class="reference internal" href="#void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)" title="void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">remap()</span></tt></a>,
<a class="reference internal" href="#void getRectSubPix(InputArray image, Size patchSize, Point2f center, OutputArray patch, int patchType)" title="void getRectSubPix(InputArray image, Size patchSize, Point2f center, OutputArray patch, int patchType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getRectSubPix()</span></tt></a>,
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#void transform(InputArray src, OutputArray dst, InputArray m)" title="void transform(InputArray src, OutputArray dst, InputArray m)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">transform()</span></tt></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">cvGetQuadrangleSubPix</span></tt> is similar to <tt class="docutils literal"><span class="pre">cvWarpAffine</span></tt>, but the outliers are extrapolated using replication border mode.</p>
</div>
</div>
<div class="section" id="warpperspective">
<h2>warpPerspective<a class="headerlink" href="#warpperspective" title="Permalink to this headline">¶</a></h2>
<p>Applies a perspective transformation to an image.</p>
<dl class="function">
<dt id="void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">warpPerspective</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, InputArray <strong>M</strong>, Size <strong>dsize</strong>, int <strong>flags</strong>=INTER_LINEAR, int <strong>borderMode</strong>=BORDER_CONSTANT, const Scalar&amp; <strong>borderValue</strong>=Scalar()<big>)</big><a class="headerlink" href="#void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar& borderValue)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.warpPerspective">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">warpPerspective</tt><big>(</big>src, M, dsize<span class="optional">[</span>, dst<span class="optional">[</span>, flags<span class="optional">[</span>, borderMode<span class="optional">[</span>, borderValue<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.warpPerspective" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvWarpPerspective(const CvArr* src, CvArr* dst, const CvMat* map_matrix, int flags, CvScalar fillval)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvWarpPerspective</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, const CvMat* <strong>map_matrix</strong>, int <strong>flags</strong>=CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS, CvScalar <strong>fillval</strong>=cvScalarAll(0) <big>)</big><a class="headerlink" href="#void cvWarpPerspective(const CvArr* src, CvArr* dst, const CvMat* map_matrix, int flags, CvScalar fillval)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image.</li>
<li><strong>dst</strong> &#8211; output image that has the size  <tt class="docutils literal"><span class="pre">dsize</span></tt>  and the same type as  <tt class="docutils literal"><span class="pre">src</span></tt> .</li>
<li><strong>M</strong> &#8211; <span class="math">3\times 3</span>  transformation matrix.</li>
<li><strong>dsize</strong> &#8211; size of the output image.</li>
<li><strong>flags</strong> &#8211; combination of interpolation methods (<tt class="docutils literal"><span class="pre">INTER_LINEAR</span></tt> or <tt class="docutils literal"><span class="pre">INTER_NEAREST</span></tt>) and the optional flag  <tt class="docutils literal"><span class="pre">WARP_INVERSE_MAP</span></tt>, that sets <tt class="docutils literal"><span class="pre">M</span></tt> as the inverse transformation ( <span class="math">\texttt{dst}\rightarrow\texttt{src}</span> ).</li>
<li><strong>borderMode</strong> &#8211; pixel extrapolation method (<tt class="docutils literal"><span class="pre">BORDER_CONSTANT</span></tt> or <tt class="docutils literal"><span class="pre">BORDER_REPLICATE</span></tt>).</li>
<li><strong>borderValue</strong> &#8211; value used in case of a constant border; by default, it equals 0.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">warpPerspective</span></tt> transforms the source image using the specified matrix:</p>
<div class="math">
<p><span class="math">\texttt{dst} (x,y) =  \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} ,
     \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right )</span></p>
</div><p>when the flag <tt class="docutils literal"><span class="pre">WARP_INVERSE_MAP</span></tt> is set. Otherwise, the transformation is first inverted with
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#double invert(InputArray src, OutputArray dst, int flags)" title="double invert(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">invert()</span></tt></a> and then put in the formula above instead of <tt class="docutils literal"><span class="pre">M</span></tt> .
The function cannot operate in-place.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)" title="void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">warpAffine()</span></tt></a>,
<a class="reference internal" href="#void resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation)" title="void resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">resize()</span></tt></a>,
<a class="reference internal" href="#void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)" title="void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">remap()</span></tt></a>,
<a class="reference internal" href="#void getRectSubPix(InputArray image, Size patchSize, Point2f center, OutputArray patch, int patchType)" title="void getRectSubPix(InputArray image, Size patchSize, Point2f center, OutputArray patch, int patchType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getRectSubPix()</span></tt></a>,
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#void perspectiveTransform(InputArray src, OutputArray dst, InputArray m)" title="void perspectiveTransform(InputArray src, OutputArray dst, InputArray m)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">perspectiveTransform()</span></tt></a></p>
</div>
</div>
<div class="section" id="initundistortrectifymap">
<h2>initUndistortRectifyMap<a class="headerlink" href="#initundistortrectifymap" title="Permalink to this headline">¶</a></h2>
<p>Computes the undistortion and rectification transformation map.</p>
<dl class="function">
<dt id="void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">initUndistortRectifyMap</tt><big>(</big>InputArray <strong>cameraMatrix</strong>, InputArray <strong>distCoeffs</strong>, InputArray <strong>R</strong>, InputArray <strong>newCameraMatrix</strong>, Size <strong>size</strong>, int <strong>m1type</strong>, OutputArray <strong>map1</strong>, OutputArray <strong>map2</strong><big>)</big><a class="headerlink" href="#void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.initUndistortRectifyMap">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">initUndistortRectifyMap</tt><big>(</big>cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type<span class="optional">[</span>, map1<span class="optional">[</span>, map2<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; map1, map2<a class="headerlink" href="#cv2.initUndistortRectifyMap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvInitUndistortRectifyMap(const CvMat* camera_matrix, const CvMat* dist_coeffs, const CvMat * R, const CvMat* new_camera_matrix, CvArr* mapx, CvArr* mapy)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvInitUndistortRectifyMap</tt><big>(</big>const CvMat* <strong>camera_matrix</strong>, const CvMat* <strong>dist_coeffs</strong>, const CvMat* <strong>R</strong>, const CvMat* <strong>new_camera_matrix</strong>, CvArr* <strong>mapx</strong>, CvArr* <strong>mapy</strong><big>)</big><a class="headerlink" href="#void cvInitUndistortRectifyMap(const CvMat* camera_matrix, const CvMat* dist_coeffs, const CvMat * R, const CvMat* new_camera_matrix, CvArr* mapx, CvArr* mapy)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvInitUndistortMap(const CvMat* camera_matrix, const CvMat* distortion_coeffs, CvArr* mapx, CvArr* mapy)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvInitUndistortMap</tt><big>(</big>const CvMat* <strong>camera_matrix</strong>, const CvMat* <strong>distortion_coeffs</strong>, CvArr* <strong>mapx</strong>, CvArr* <strong>mapy</strong><big>)</big><a class="headerlink" href="#void cvInitUndistortMap(const CvMat* camera_matrix, const CvMat* distortion_coeffs, CvArr* mapx, CvArr* mapy)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cameraMatrix</strong> &#8211; Input camera matrix  <span class="math">A=\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}</span> .</li>
<li><strong>distCoeffs</strong> &#8211; Input vector of distortion coefficients  <span class="math">(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]])</span>  of 4, 5, or 8 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</li>
<li><strong>R</strong> &#8211; Optional rectification transformation in the object space (3x3 matrix).  <tt class="docutils literal"><span class="pre">R1</span></tt>  or  <tt class="docutils literal"><span class="pre">R2</span></tt> , computed by  <a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)" title="void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">stereoRectify()</span></tt></a>  can be passed here. If the matrix is empty, the identity transformation is assumed. In <tt class="docutils literal"><span class="pre">cvInitUndistortMap</span></tt> R assumed to be an identity matrix.</li>
<li><strong>newCameraMatrix</strong> &#8211; New camera matrix  <span class="math">A'=\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}</span> .</li>
<li><strong>size</strong> &#8211; Undistorted image size.</li>
<li><strong>m1type</strong> &#8211; Type of the first output map that can be  <tt class="docutils literal"><span class="pre">CV_32FC1</span></tt>  or  <tt class="docutils literal"><span class="pre">CV_16SC2</span></tt> . See  <a class="reference internal" href="#void convertMaps(InputArray map1, InputArray map2, OutputArray dstmap1, OutputArray dstmap2, int dstmap1type, bool nninterpolation)" title="void convertMaps(InputArray map1, InputArray map2, OutputArray dstmap1, OutputArray dstmap2, int dstmap1type, bool nninterpolation)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">convertMaps()</span></tt></a> for details.</li>
<li><strong>map1</strong> &#8211; The first output map.</li>
<li><strong>map2</strong> &#8211; The second output map.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes the joint undistortion and rectification transformation and represents the result in the form of maps for
<a class="reference internal" href="#void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)" title="void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">remap()</span></tt></a> . The undistorted image looks like original, as if it is captured with a camera using the camera matrix <tt class="docutils literal"><span class="pre">=newCameraMatrix</span></tt> and zero distortion. In case of a monocular camera, <tt class="docutils literal"><span class="pre">newCameraMatrix</span></tt> is usually equal to <tt class="docutils literal"><span class="pre">cameraMatrix</span></tt> , or it can be computed by
<a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat getOptimalNewCameraMatrix(InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, double alpha, Size newImgSize, Rect* validPixROI, bool centerPrincipalPoint)" title="Mat getOptimalNewCameraMatrix(InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, double alpha, Size newImgSize, Rect* validPixROI, bool centerPrincipalPoint)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getOptimalNewCameraMatrix()</span></tt></a> for a better control over scaling. In case of a stereo camera, <tt class="docutils literal"><span class="pre">newCameraMatrix</span></tt> is normally set to <tt class="docutils literal"><span class="pre">P1</span></tt> or <tt class="docutils literal"><span class="pre">P2</span></tt> computed by
<a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)" title="void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">stereoRectify()</span></tt></a> .</p>
<p>Also, this new camera is oriented differently in the coordinate space, according to <tt class="docutils literal"><span class="pre">R</span></tt> . That, for example, helps to align two heads of a stereo camera so that the epipolar lines on both images become horizontal and have the same y- coordinate (in case of a horizontally aligned stereo camera).</p>
<p>The function actually builds the maps for the inverse mapping algorithm that is used by
<a class="reference internal" href="#void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)" title="void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">remap()</span></tt></a> . That is, for each pixel
<span class="math">(u, v)</span> in the destination (corrected and rectified) image, the function computes the corresponding coordinates in the source image (that is, in the original image from camera). The following process is applied:</p>
<div class="math">
<p><span class="math">\begin{array}{l} x  \leftarrow (u - {c'}_x)/{f'}_x  \\ y  \leftarrow (v - {c'}_y)/{f'}_y  \\{[X\,Y\,W]} ^T  \leftarrow R^{-1}*[x \, y \, 1]^T  \\ x'  \leftarrow X/W  \\ y'  \leftarrow Y/W  \\ x&quot;  \leftarrow x' (1 + k_1 r^2 + k_2 r^4 + k_3 r^6) + 2p_1 x' y' + p_2(r^2 + 2 x'^2)  \\ y&quot;  \leftarrow y' (1 + k_1 r^2 + k_2 r^4 + k_3 r^6) + p_1 (r^2 + 2 y'^2) + 2 p_2 x' y'  \\ map_x(u,v)  \leftarrow x&quot; f_x + c_x  \\ map_y(u,v)  \leftarrow y&quot; f_y + c_y \end{array}</span></p>
</div><p>where
<span class="math">(k_1, k_2, p_1, p_2[, k_3])</span> are the distortion coefficients.</p>
<p>In case of a stereo camera, this function is called twice: once for each camera head, after
<a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)" title="void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">stereoRectify()</span></tt></a> , which in its turn is called after
<a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, int flags,TermCriteria criteria)" title="double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, int flags,TermCriteria criteria)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">stereoCalibrate()</span></tt></a> . But if the stereo camera was not calibrated, it is still possible to compute the rectification transformations directly from the fundamental matrix using
<a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#bool stereoRectifyUncalibrated(InputArray points1, InputArray points2, InputArray F, Size imgSize, OutputArray H1, OutputArray H2, double threshold)" title="bool stereoRectifyUncalibrated(InputArray points1, InputArray points2, InputArray F, Size imgSize, OutputArray H1, OutputArray H2, double threshold)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">stereoRectifyUncalibrated()</span></tt></a> . For each camera, the function computes homography <tt class="docutils literal"><span class="pre">H</span></tt> as the rectification transformation in a pixel domain, not a rotation matrix <tt class="docutils literal"><span class="pre">R</span></tt> in 3D space. <tt class="docutils literal"><span class="pre">R</span></tt> can be computed from <tt class="docutils literal"><span class="pre">H</span></tt> as</p>
<div class="math">
<p><span class="math">\texttt{R} =  \texttt{cameraMatrix} ^{-1}  \cdot \texttt{H} \cdot \texttt{cameraMatrix}</span></p>
</div><p>where <tt class="docutils literal"><span class="pre">cameraMatrix</span></tt> can be chosen arbitrarily.</p>
</div>
<div class="section" id="getdefaultnewcameramatrix">
<h2>getDefaultNewCameraMatrix<a class="headerlink" href="#getdefaultnewcameramatrix" title="Permalink to this headline">¶</a></h2>
<p>Returns the default new camera matrix.</p>
<dl class="function">
<dt id="Mat getDefaultNewCameraMatrix(InputArray cameraMatrix, Size imgsize, bool centerPrincipalPoint)">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descname">getDefaultNewCameraMatrix</tt><big>(</big>InputArray <strong>cameraMatrix</strong>, Size <strong>imgsize</strong>=Size(), bool <strong>centerPrincipalPoint</strong>=false <big>)</big><a class="headerlink" href="#Mat getDefaultNewCameraMatrix(InputArray cameraMatrix, Size imgsize, bool centerPrincipalPoint)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.getDefaultNewCameraMatrix">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">getDefaultNewCameraMatrix</tt><big>(</big>cameraMatrix<span class="optional">[</span>, imgsize<span class="optional">[</span>, centerPrincipalPoint<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; retval<a class="headerlink" href="#cv2.getDefaultNewCameraMatrix" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cameraMatrix</strong> &#8211; Input camera matrix.</li>
<li><strong>imgsize</strong> &#8211; Camera view image size in pixels.</li>
<li><strong>centerPrincipalPoint</strong> &#8211; Location of the principal point in the new camera matrix. The parameter indicates whether this location should be at the image center or not.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function returns the camera matrix that is either an exact copy of the input <tt class="docutils literal"><span class="pre">cameraMatrix</span></tt> (when <tt class="docutils literal"><span class="pre">centerPrinicipalPoint=false</span></tt> ), or the modified one (when <tt class="docutils literal"><span class="pre">centerPrincipalPoint=true</span></tt>).</p>
<p>In the latter case, the new camera matrix will be:</p>
<div class="math">
<p><span class="math">\begin{bmatrix} f_x &amp;&amp; 0 &amp;&amp; ( \texttt{imgSize.width} -1)*0.5  \\ 0 &amp;&amp; f_y &amp;&amp; ( \texttt{imgSize.height} -1)*0.5  \\ 0 &amp;&amp; 0 &amp;&amp; 1 \end{bmatrix} ,</span></p>
</div><p>where
<span class="math">f_x</span> and
<span class="math">f_y</span> are
<span class="math">(0,0)</span> and
<span class="math">(1,1)</span> elements of <tt class="docutils literal"><span class="pre">cameraMatrix</span></tt> , respectively.</p>
<p>By default, the undistortion functions in OpenCV (see
<a class="reference internal" href="#void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)" title="void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">initUndistortRectifyMap()</span></tt></a>,
<a class="reference internal" href="#void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix)" title="void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">undistort()</span></tt></a>) do not move the principal point. However, when you work with stereo, it is important to move the principal points in both views to the same y-coordinate (which is required by most of stereo correspondence algorithms), and may be to the same x-coordinate too. So, you can form the new camera matrix for each view where the principal points are located at the center.</p>
</div>
<div class="section" id="undistort">
<h2>undistort<a class="headerlink" href="#undistort" title="Permalink to this headline">¶</a></h2>
<p>Transforms an image to compensate for lens distortion.</p>
<dl class="function">
<dt id="void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">undistort</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, InputArray <strong>cameraMatrix</strong>, InputArray <strong>distCoeffs</strong>, InputArray <strong>newCameraMatrix</strong>=noArray() <big>)</big><a class="headerlink" href="#void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.undistort">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">undistort</tt><big>(</big>src, cameraMatrix, distCoeffs<span class="optional">[</span>, dst<span class="optional">[</span>, newCameraMatrix<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.undistort" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvUndistort2(const CvArr* src, CvArr* dst, const CvMat* camera_matrix, const CvMat* distortion_coeffs, const CvMat* new_camera_matrix)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvUndistort2</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, const CvMat* <strong>camera_matrix</strong>, const CvMat* <strong>distortion_coeffs</strong>, const CvMat* <strong>new_camera_matrix</strong>=0 <big>)</big><a class="headerlink" href="#void cvUndistort2(const CvArr* src, CvArr* dst, const CvMat* camera_matrix, const CvMat* distortion_coeffs, const CvMat* new_camera_matrix)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Input (distorted) image.</li>
<li><strong>dst</strong> &#8211; Output (corrected) image that has the same size and type as  <tt class="docutils literal"><span class="pre">src</span></tt> .</li>
<li><strong>cameraMatrix</strong> &#8211; Input camera matrix  <span class="math">A = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}</span> .</li>
<li><strong>distCoeffs</strong> &#8211; Input vector of distortion coefficients  <span class="math">(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]])</span>  of 4, 5, or 8 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</li>
<li><strong>newCameraMatrix</strong> &#8211; Camera matrix of the distorted image. By default, it is the same as  <tt class="docutils literal"><span class="pre">cameraMatrix</span></tt>  but you may additionally scale and shift the result by using a different matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function transforms an image to compensate radial and tangential lens distortion.</p>
<p>The function is simply a combination of
<a class="reference internal" href="#void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)" title="void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">initUndistortRectifyMap()</span></tt></a> (with unity <tt class="docutils literal"><span class="pre">R</span></tt> ) and
<a class="reference internal" href="#void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)" title="void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">remap()</span></tt></a> (with bilinear interpolation). See the former function for details of the transformation being performed.</p>
<p>Those pixels in the destination image, for which there is no correspondent pixels in the source image, are filled with zeros (black color).</p>
<p>A particular subset of the source image that will be visible in the corrected image can be regulated by <tt class="docutils literal"><span class="pre">newCameraMatrix</span></tt> . You can use
<a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat getOptimalNewCameraMatrix(InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, double alpha, Size newImgSize, Rect* validPixROI, bool centerPrincipalPoint)" title="Mat getOptimalNewCameraMatrix(InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, double alpha, Size newImgSize, Rect* validPixROI, bool centerPrincipalPoint)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getOptimalNewCameraMatrix()</span></tt></a> to compute the appropriate <tt class="docutils literal"><span class="pre">newCameraMatrix</span></tt>  depending on your requirements.</p>
<p>The camera matrix and the distortion parameters can be determined using
<a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)" title="double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">calibrateCamera()</span></tt></a> . If the resolution of images is different from the resolution used at the calibration stage,
<span class="math">f_x, f_y, c_x</span> and
<span class="math">c_y</span> need to be scaled accordingly, while the distortion coefficients remain the same.</p>
</div>
<div class="section" id="undistortpoints">
<h2>undistortPoints<a class="headerlink" href="#undistortpoints" title="Permalink to this headline">¶</a></h2>
<p>Computes the ideal point coordinates from the observed point coordinates.</p>
<dl class="function">
<dt id="void undistortPoints(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray P)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">undistortPoints</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, InputArray <strong>cameraMatrix</strong>, InputArray <strong>distCoeffs</strong>, InputArray <strong>R</strong>=noArray(), InputArray <strong>P</strong>=noArray()<big>)</big><a class="headerlink" href="#void undistortPoints(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray P)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvUndistortPoints(const CvMat* src, CvMat* dst, const CvMat* camera_matrix, const CvMat* dist_coeffs, const CvMat* R, const CvMat* P)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvUndistortPoints</tt><big>(</big>const CvMat* <strong>src</strong>, CvMat* <strong>dst</strong>, const CvMat* <strong>camera_matrix</strong>, const CvMat* <strong>dist_coeffs</strong>, const CvMat* <strong>R</strong>=0, const CvMat* <strong>P</strong>=0 <big>)</big><a class="headerlink" href="#void cvUndistortPoints(const CvMat* src, CvMat* dst, const CvMat* camera_matrix, const CvMat* dist_coeffs, const CvMat* R, const CvMat* P)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Observed point coordinates, 1xN or Nx1 2-channel (CV_32FC2 or CV_64FC2).</li>
<li><strong>dst</strong> &#8211; Output ideal point coordinates after undistortion and reverse perspective transformation. If matrix <tt class="docutils literal"><span class="pre">P</span></tt> is identity  or omitted, <tt class="docutils literal"><span class="pre">dst</span></tt> will contain normalized point coordinates.</li>
<li><strong>cameraMatrix</strong> &#8211; Camera matrix  <span class="math">\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}</span> .</li>
<li><strong>distCoeffs</strong> &#8211; Input vector of distortion coefficients  <span class="math">(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]])</span>  of 4, 5, or 8 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</li>
<li><strong>R</strong> &#8211; Rectification transformation in the object space (3x3 matrix).  <tt class="docutils literal"><span class="pre">R1</span></tt>  or  <tt class="docutils literal"><span class="pre">R2</span></tt>  computed by  <a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)" title="void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">stereoRectify()</span></tt></a>  can be passed here. If the matrix is empty, the identity transformation is used.</li>
<li><strong>P</strong> &#8211; New camera matrix (3x3) or new projection matrix (3x4).  <tt class="docutils literal"><span class="pre">P1</span></tt>  or  <tt class="docutils literal"><span class="pre">P2</span></tt>  computed by  <a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)" title="void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">stereoRectify()</span></tt></a>  can be passed here. If the matrix is empty, the identity new camera matrix is used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function is similar to
<a class="reference internal" href="#void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix)" title="void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">undistort()</span></tt></a> and
<a class="reference internal" href="#void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)" title="void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">initUndistortRectifyMap()</span></tt></a>  but it operates on a sparse set of points instead of a raster image. Also the function performs a reverse transformation to
<a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian, double aspectRatio)" title="void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian, double aspectRatio)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">projectPoints()</span></tt></a> . In case of a 3D object, it does not reconstruct its 3D coordinates, but for a planar object, it does, up to a translation vector, if the proper <tt class="docutils literal"><span class="pre">R</span></tt> is specified.</p>
<div class="highlight-cpp"><div class="highlight"><pre>// (u,v) is the input point, (u&#39;, v&#39;) is the output point
// camera_matrix=[fx 0 cx; 0 fy cy; 0 0 1]
// P=[fx&#39; 0 cx&#39; tx; 0 fy&#39; cy&#39; ty; 0 0 1 tz]
x&quot; = (u - cx)/fx
y&quot; = (v - cy)/fy
(x&#39;,y&#39;) = undistort(x&quot;,y&quot;,dist_coeffs)
[X,Y,W]T = R*[x&#39; y&#39; 1]T
x = X/W, y = Y/W
// only performed if P=[fx&#39; 0 cx&#39; [tx]; 0 fy&#39; cy&#39; [ty]; 0 0 1 [tz]] is specified
u&#39; = x*fx&#39; + cx&#39;
v&#39; = y*fy&#39; + cy&#39;,
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">undistort()</span></tt> is an approximate iterative algorithm that estimates the normalized original point coordinates out of the normalized distorted point coordinates (&#8220;normalized&#8221; means that the coordinates do not depend on the camera matrix).</p>
<p>The function can be used for both a stereo camera head or a monocular camera (when R is empty).</p>
</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org">Q&A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="miscellaneous_transformations.html" title="Miscellaneous Image Transformations"
             >next</a> |</li>
        <li class="right" >
          <a href="filtering.html" title="Image Filtering"
             >previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 3.0.0-beta documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="imgproc.html" >imgproc. Image Processing</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014, opencv dev team.
      Last updated on May 16, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
      <a href="../../../_sources/modules/imgproc/doc/geometric_transformations.txt" rel="nofollow">Show this page source.</a>
    </div>
  </body>
</html>